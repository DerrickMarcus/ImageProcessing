---
header: MATLAB: Image Processing / 陈彦旭 / ${today}
footer: ${pageNo} of ${totalPages}
---

# MATLAB 大作业：图像处理

>姓名：陈彦旭
>
>学号：2022010597 班级：无24



目录

[toc]



## Part 1 基础知识

在 MATLAB 中，像素值用 uint8 类型表示，参与浮点数运算之前需要转成double型。

利用 MATLAB 提供的 Image file I/O 函数分别完成以下处理：

（1）以测试图像的中心为圆心，图像的长和宽中较小值的一半为半径画一个红颜色的圆。

利用 `size()` 函数获取图像的宽度与长度，从而得到圆的半径。遍历图像中的每一个像素，计算它与图像中心的距离，距离等于半径（或误差极小）时将该像素的 RGB 赋值为 [255, 0, 0] 红色。

效果如下：

![exp1_1](.\exp1_1.jpg)



（2）将测试图像涂成国际象棋状的“黑白格”的样子，其中“黑”即黑色，“白”则意味着保留原图。

将图像划分为标准国际象棋棋盘的 8*8 块，将某一块区域涂成黑色的条件是：该区域的行号与列号之和为偶数，然后将该区域赋值为 `black_block = zeros(height / 8, width / 8, 3)` 。

效果如下：

![exp1_2](.\exp1_2.jpg)






## Part 2 图像压缩编码

（1）图像的预处理是将每个像素灰度值减去 128，这个步骤是否可以在变换域进行？请在测试图像中截取一块验证你的结论。

将图像的每个像素灰度值减去 128，也即对整个图像矩阵减去一个全 128 的矩阵。由于 DCT 为线性变换，那么预处理图像经过变换后，等于原始图像先经过 DCT 变换，然后在变换域减去一个全 128 矩阵 DCT 变换之后的结果。

同时注意到一个全 128 的矩阵只包含直流分量，因此经过 DCT 之后只有左上角元素，其余位置均为 0 。可以证明，一个全 1 的 $N\times N$ 矩阵，DCT 后为左上角元素为 $N$ 。因此当我取一个全 128 的 $8\times 8$ 矩阵的 DCT 变换，结果是只有左上角为128*8，其余位置为 0 。
$$
\begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & 1 & \cdots & 1 \\
\vdots & \vdots & \ddots & \vdots \\
1 & 1 & \cdots & 1 \\
\end{bmatrix}
\xrightarrow{\text{DCT}}
\\
\begin{bmatrix}
n & 0 & \cdots & 0 \\
0 & 0 & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \cdots & 0 \\
\end{bmatrix}
$$
关键代码如下：

```matlab
% preprocess then transform
res1 = dct2(test - 128);

% transform then process
res2 = dct2(test);
res2(1, 1) = res2(1, 1) - 128 * N;
```



![fig2_1](.\exp2_1.png)

通过打印两种方法得到的矩阵可以发现几乎相同。最后经过计算 `max(max(abs(res1 - res2)))` ，而这误差绝对值得最大值为 4.5475e-13 ，计算 `sum(sum(abs(res1 - res2)))` ，二者误差的绝对值总和为 7.7349e-13，因此可认为两种方法处理过后结果相等。



（2）请编程实现二维 DCT，并和 MATLAB 自带的库函数 dct2 比较是否一致。

直接根据 DCT 变换矩阵的规律，除了第一行之外，其他部分的系数为等差数列，因此直接使用列向量乘行向量，得到余弦内系数，避免使用循环增加时间。首先得到 D 算子：

```matlab
function D = get_DCT_D(N)
    D = (1:1:N - 1)' .* (1:2:2 * N - 1);
    D = [sqrt(1/2) * ones(1, N); cos(D * pi / (2 * N))];
    D = D * sqrt(2 / N);
end
```

然后得到变换后的 C 矩阵：

```matlab
function C = myDCT(P)
    [M, N] = size(P);
    C = get_DCT_D(M) * P * get_DCT_D(N)';
end
```

仍然选取一块图像中的 $8\times 8$ 矩阵，分别打印使用库函数 `dct2()` 和自创函数 `myCPU()` 处理后的结果，发现误差极小，可以认为两种方法结果一致。

![exp2_2](.\exp2_2.png)





（3）如果将 DCT 系数矩阵中右侧四列的系数全部置零，逆变换后的图像会发生什么变化？选取一块图验证你的结论。如果左侧的四列置零呢？





（4）如果对 DCT 系数分别做转置、旋转 90 度和旋转 180 度操作（rot90），逆变换后恢复的图像有何变化？选取一块图验证你的结论。





（5）如果认为如果认为差分编码是一个系统，请绘出这个系统的频率响应，说明它是一个_____(低通、高通、带通、带阻)滤波器。DC 系数先进行差分编码再进行熵编码，说明 DC 系数的_____频率分量更多。  



（6）DC 预测误差的取值和 Category 值有何关系?如何利用预测误差计算出其 Category ？



（7）你知道哪些实现 Zig-Zag 扫描的方法？请利用 MATLAB 的强大功能设计一种最佳方法。



（8）对测试图像分块、DCT 和量化，将量化后的系数写成矩阵的形式，其中每一列为一个块的 DCT 系数 Zig-Zag 扫描后形成的列矢量，第一行为各个块的 DC 系数。



（9）请实现本章介绍的 JPEG 编码(不包括写 JFIF 文件)，输出为 DC 系数的码流、AC 系数的码流、图像高度和图像宽度，将这四个变量写入 jpegcodes.mat 文件。



（10）计算压缩比(输入文件长度/输出码流长度)，注意转换为相同进制。





（11）请实现本章介绍的 JPEG 解码，输入是你生成的 jpegcodes.mat 文件。分别用客观(PSNR)和主观方式评价编解码效果如何。



（12）将量化步长减小为原来的一半，重做编解码。同标准量化步长的情况比较压缩比和图像质量。



（13）看电视时偶尔能看到美丽的雪花图像(见 snow.mat )，请对其编解码。和测试图像的压缩比和图像质量进行比较，并解释比较结果。





## Part 3 信息隐藏

（1）实现本章介绍的空域隐藏方法和提取方法。验证其抗 JPEG 编码能力。



（2）依次实现本章介绍的三种变换域信息隐藏方法和提取方法，分析嵌密方法的隐蔽性以及嵌密后 JPEG 图像的质量变化和压缩比变化。





## Part 4 人脸检测

（1）所给资料 Faces 目录下包含从网图中截取的 28 张人脸，试以其作为样本训练人脸标准 $\text{v}$ 。

​	（a）样本人脸大小不一，是否需要首先将图像调整为相同大小？

​	（b）假设 $L$ 分别取 3,4,5，所得三个 $\text{v}$ 之间有何关系？





（2）设计一种从任意大小的图片中检测任意多张人脸的算法并编程实现（输出图像在判定为人脸的位置加上红色的方框）。随意选取一张多人照片（比如支部活动或者足球比赛），对程序进行测试。尝试 $L$ 分别取不同的值，评价检测结果有何区别。





（2）对上述图像分别进行如下处理后

​	（a）顺时针旋转 90°（imrotate）；

​	（b）保持高度不变，宽度拉伸为原来的 2 倍（imresize）；

​	（c）适当改变颜色（imadjust）；

再试试你的算法检测结果如何？并分析所得结果。





（4）如果可以重新选择人脸样本训练标准，你觉得应该如何选取？
